# Helloworld Build and Deploy Pipeline
# Triggers only on push to the branch che 

# 1. Builds Atlas image, tags image with 'prod' and 'commit-sha', and pushes to ACR.
# 2. Create and run DB Migration script on the QA database
# 3. Deploy image to QA 

name: build_and_deploy_hello_world

on:
  push:
    branches:
      - che
#################################################################################
# The name of the job is build-deploy-kub. The job runs on ubuntu. I have defined some
#environment variables. The first group of variables are for the docker image. Image tag is a
# github runner which is incremented each time a new build is triggered. 
# I want to deploy to an AKS cluster. Th next variables are for the cluster.
#
jobs:

  build-deploy-kubn:
    runs-on: ubuntu-latest
    env:
      DOCKER_REPOSITORY: eche21 # name of Docker Hub ID
      IMAGE_NAME: helloapp
      IMAGE_TAG: ${{ github.run_number }} # $GITHUB_RUN_NUMBER
      
      CLUSTER_NAME: RegScale
      CLUSTER_RESOURCE_GROUP: Corporate
      NAMESPACE: demo-che

      REGISTRY_NAME: democheregistry
     
    steps:
#    
#This step checks out the application source code
#
    - name: Git Checkout
      uses: actions/checkout@v2
# 
# Connect to Azure Container registry (ACR)
    - name: Connect to ACR 
      uses: azure/docker-login@v1
      with:
        login-server: ${{ env.REGISTRY_NAME }}.azurecr.io
        username: ${{ secrets.REGISTRY_USERNAME }} 
        password: ${{ secrets.REGISTRY_PASSWORD }}
#This step builds the docker image using docker build. The image is tagged.
# We can also use a step predefined
#in github market place.
# But we use the command line. The docker cli and the docker daemon are already installed inside
# the runner. This gives more flexibility and more control.
#
#    - name: Build Docker Image
#      run:
#        docker build ./FirstApp/ --file ./FirstApp/Dockerfile --tag $DOCKER_REPOSITORY/$IMAGE_NAME:$GITHUB_RUN_NUMBER --build-arg=token=secrets.MYTOKEN --no-cache
#
# Container build and push to a Azure Container registry (ACR)
    - name: Build and Push to ACR 
      run: |
        docker build  --file ./FirstApp/Dockerfile    -t ${{ env.REGISTRY_NAME }}.azurecr.io/myimage:${{ github.sha }} .
        docker push ${{ env.REGISTRY_NAME }}.azurecr.io/myimage:${{ github.sha }}
#
#
#SCAN THE IMAGE using the open source tool trivy. Trivy download the image and scans it and look
# for any severity
#
    - name: Run Trivy vulnerability scanner
      uses: aquasecurity/trivy-action@master
      continue-on-error: true
      with:
        image-ref: 'docker.io/${{ env.REGISTRY_NAME }}.azurecr.io/myimage:${{ github.sha }}'
        format: 'table'
        exit-code: '1'
        ignore-unfixed: true
        vuln-type: 'os,library'
        severity: 'MEDIUM,HIGH,CRITICAL'
#
    
# Set the target Azure Kubernetes Service (AKS) cluster. 
    - uses: azure/aks-set-context@v1
      with:
        creds: '${{ secrets.AZURE_CREDENTIALS }}'
        cluster-name: ${{ env.CLUSTER_NAME }}
        resource-group: ${{ env.CLUSTER_RESOURCE_GROUP }}
    
    # Create namespace if doesn't exist
   # - run: |
   #     kubectl create namespace ${{ env.NAMESPACE }} --dry-run -o json | kubectl apply -f -
    
    # Create imagepullsecret for Azure Container registry (ACR)
    - uses: azure/k8s-create-secret@v1
      with:
        container-registry-url: ${{ env.REGISTRY_NAME }}.azurecr.io
        container-registry-username: ${{ secrets.REGISTRY_USERNAME }}
        container-registry-password: ${{ secrets.REGISTRY_PASSWORD }}
        secret-name: ${{ env.REGISTRY_NAME }}-registry-connection
        namespace: ${{ env.NAMESPACE }}


